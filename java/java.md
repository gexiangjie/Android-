# 一.面向对象的三个特性以及理解.
**封装**：是指对象把自己的数据和对数据的操作封装在了一起；<br />
---->减少了大量的冗余代码<br />
---->封装将复杂的功能封装起来，对外开放一个接口，简单调用即可。<br />
将描述事物的数据和操作封装在一起，形成一个类；被封装的数据和操作只有通过提供的公共方法才能被外界访问（封装隐藏了对象的属性和实施细节），私有属性和方法是无法被访问的，表现了封装的隐藏性，增加数据的安全性。

**继承：**是指子类对父类的继承，子类把父类的数据和对数据的操作继承了过来，同时又增添了自己的数据和对数据的操作；<br />
---->单根性，传递性<br />
---->减少了类的冗余代码<br />
---->让类与类之间产生关系，为多态打下基础<br />
若一个新类继承了原有类的属性和方法，并增加了自己的新属性和新方法，称之为派生类，派生类就继承了原有类；当子类继承父类的时候，子类不继承父类的构造函数，但是子类生成对象时(new Student())默认会先执行父类无参的构造函数（实例化对象，让子类可以使用父类的成员），当父类定义有参构造函数时，无参构造函数就会被干掉，这时子类会报错，解决方案是:<br />
1>.在父类重新定义无参构造函数<br />
2>.子类的构造函数：base()，调用有参构造函数，函数体中只需初始化特有属性；如果不想执行父类的构造函数，可以通过参数的不同调用父类一个空的构造函数。

**多态：**主要有两种类型的多态。一种是操作的名称的多态，即多个操作的名称一样，但接受的消息类型必须不同；另一种是与继承相关的多态，来自不同类型的对象对同一操作的调用产生不同的效果。<br />
----->虚方法 virtual override<br />
----->抽象类 abstract override<br />
----->接口 interface<br />
很重要的一个概念，一个接口，多个方法。通过继承实现的不同对象调用相同的方法，进而有不同的行为<br />
抽象父类有方法Body(),子类继承父类重写Body方法，new出不同的对象，这些对象去执行相同的Body方法，有不同的执行结果，这就是多态。上述例子中想要停止这种继承重写，用关键字sealed修饰类即可。

**重写：**发生在子类和父类之间，当子类继承父类中的方法时，子类中的方法与父类方法的名称，参数个数，参数类型完全一致时，称子类重写了父类的方法。

**重载：**一个类中的多个方法的名称相同，参数个数或者参数类型不同，则称为重载方法

**覆盖：**子类重新实现了父类的方法，而隐藏只是把父类中的方法藏了起来，通过父类的引用来调用这个方法的时候，这个被隐藏的方法就被激活了。

# 二.Java 中实现多态的机制是什么
靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。
# 三.Java中的String，StringBuilder，StringBuffer三者的区别
**String**：适用于少量的字符串操作的情况<br />
**StringBuilder**：适用于单线程下在字符缓冲区进行大量操作的情况<br />
**StringBuffer**：适用多线程下在字符缓冲区进行大量操作的情况<br />
# 四.断点续传和下载原理分析
断点续传和断点下载都是用的RandomAccessFile, 它具有移动指定的文件大小的位置的功能seek 。<br />
断点续传是由服务器给客户端一个已经上传的位置标记position，然后客户端再将文件指针移动到相应的position，通过输入流将文件剩余部分读出来传输给服务器
断点下载 是由客户端告诉服务器已经下载的大小，然后服务器会将指针移动到相应的position，继续读出，把文件返回给客户端。 当然为了下载的更快一下，也可以多线程下载，那么基本实现就是给每个线程分配固定的字节的文件，分别去读

# 五.堆和栈在内存中的区别是什么?
**栈内存:** 栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。

**堆内存:** 存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。
所以堆与栈的区别很明显：<br />
 *1.栈内存存储的是局部变量而堆内存存储的是实体；<br />*
 *2.栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；<br />*
 *3.栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。*
# 六.synchronized和Lock的区别
1. Lock是个接口，而synchronized是java关键字，synchronized是内置语言实现
2. synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象的发生；而Lock在发生异常时，如果没有主动通过unlock()去释放锁，则很有可能造成死锁现象，因此使用Lock时需要在finally块中释放锁;
3. Lock可以让等待锁的线程相应中断；而synchronized不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断;
4. 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到;
5. Lock可以提高多个线程读操作的效率
在性能上来说，如果资源竞争不激烈的话，两者的性能是差不多的；而当资源竞争非常激烈（即有大量线程同时竞争）时，Lock的性能要远远优于synchronized

# 八.泛型 协变和逆变.
1.kotlin 使用类似 C# 泛型的方式，将型变分为协变，逆变，分别提供in，out 关键字对其进行支持；

**协变**（covariant：Foo<父类> => Foo<子类>）
协变为父类泛型型变为具体子类，Kotlin 提供 in 关键字，来代替 Java 中<? extends E> 的通配符语法，同时为了解决Java中泛型型变类型擦除中，所引起的类型转换安全，Kotlin 采用了 C# 的策略，即协变类型作为消费者，只能读取而不能写入；

**逆变（**contravariance：Foo<子类> => Foo<父类>）
逆变为子类型型变为具体父类，Kotlin 提供 out 关键字，来代替 Java 中<? super E> 的通配符语法，同样采用了 C# 的策略，逆变类型作为生产者，只能写入而不能读取；

2.泛型擦除<br />
1.类型擦除有哪些好处?<br />
	a.运行时内存负担小; List<String> List<Double> 在内存中只是List<br />
	b.兼容性好;<br />
2.泛型擦除有哪些问题?<br />
	a.基本类型无法作为泛型实参;<br />
	b.泛型类型无法用作方法重载;<br />
	c.泛型类型无法当做真实类型使用;<br />
	d.静态方法无法引用类泛型参数;<br />
	e.类型强转的运行时开销;<br />
# 九.重写equals()方法为什么要重写hashcode()方法？
object对象中的 public boolean equals(Object obj)，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true；
注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下：<br />
(1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true <br />
(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false<br />
     如果不重写equals，那么比较的将是对象的引用是否指向同一块内存地址，重写之后目的是为了比较两个对象的value值是否相等。特别指出利用equals比较八大包装对象（如int，float等）和String类（因为该类已重写了equals和hashcode方法）对象时，默认比较的是值，在比较其它自定义对象时都是比较的引用地址。
hashcode是用于散列数据的快速存取，如利用HashSet/HashMap/Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。<br />
     这样如果我们对一个对象重写了equals，意思是只要对象的成员变量值都相等那么equals就等于true，但不重写hashcode，那么我们再new一个新的对象，当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象，导致混淆，因此，就也需要重写hashcode()。
# 十.分代回收算法各代对应的回收算法.
* 对象分类
这种算法并不是一种新的算法，而是根据对象的存活周期的不同而将内存分为几块，分别是新生代、老年代和永久代。<br /><br />
**新生代**：朝生夕灭的对象（例如方法的局部变量等）；<br />
**老年代**：存活的比较久但还是要死的对象（例如缓存对象、单例对象等）；<br />
**永久代：**对象生成后几乎不灭的对象（例如加载过的类信息）；

* 内存区域<br />
    新生代和老年代都在Java堆，永久代在方法区。
* Java对象的回收<br /><br />
    **新生代：**采用复制算法，新生对象一般存活率较低，因此可以不使用50%的内存空间作为空闲，一般的使用两块10%的内存。<br />
    作为空闲和活动区间，而另外80%的内存则是用来给新建对象分配内存的。一旦发生GC，将10%的活动区间与另外80%中存活的对象转移到10%的空闲空间，接下来，将之前90%的内存全部释放。堆大小=新生代+老年代，新生代和老年代的比例为1：2，新生代细分为一块交大的Eden空间和两块较小的Survivor空间，分别被命名为from和to。<br /><br />
**老年代：**老年代中使用标记-清除或者标记-整理算法进行垃圾回收，回收次数相对较少，每次回收时间比较长。
方法区对象回收<br /><br />
    **永久代**指的是虚拟机内存中的方法区，永久代垃圾回收 比较少，效率也比较低，但也必须进行垃圾回收，否则永久代内存不够用时仍然会抛出OutOfMemoryError异常。永久代也使用标记-清除或标记-整理算法进行垃圾回收。

#十一.线程的状态.
```
public enum State {
    //线程刚创建
    NEW,
 
    //在JVM中正在运行的线程
    RUNNABLE,
 
    //线程处于阻塞状态，等待监视锁，可以重新进行同步代码块中执行
    BLOCKED,
 
    //等待状态
    WAITING,
 
    //调用sleep() join() wait()方法可能导致线程处于等待状态
    TIMED_WAITING,
 
    //线程执行完毕，已经退出
    TERMINATED;
}
```
原文链接：[https://blog.csdn.net/qq_36186690/article/details/82939190](https://blog.csdn.net/qq_36186690/article/details/82939190)

# 十二.haspmap
## 一). 1.7和1.8区别,扩容因子
### 1. jdk1.7和1.8区别
(1）JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么他们为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。

(2）扩容后数据存储位置的计算方式也不一样：1. 在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞）（hash值 & length-1）

(3）JDK1.7的时候使用的是数组+ 单链表的数据结构。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构（当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（n）变成O（logN）提高了效率）

### 2.为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢？

//其实就是当这个Map中实际插入的键值对的值的大小如果大于这个默认的阈值的时候（初始是16*0.75=12）的时候才会触发扩容，

```
//这个是在JDK1.8中的先插入后扩容
if (++size > threshold)
            resize();
```
其实这个问题也是JDK8对HashMap中，主要是因为对链表转为红黑树进行的优化，因为你插入这个节点的时候有可能是普通链表节点，也有可能是红黑树节点.<br />
但是在JDK1.7中的话，是先进行扩容后进行插入的，就是当你发现你插入的桶是不是为空，如果不为空说明存在值就发生了hash冲突，那么就必须得扩容，但是如果不发生Hash冲突的话，说明当前桶是空的（后面并没有挂有链表），那就等到下一次发生Hash冲突的时候在进行扩容，但是当如果以后都没有发生hash冲突产生，那么就不会进行扩容了，减少了一次无用扩容，也减少了内存的使用

### 3.为什么在JDK1.8中进行对HashMap优化的时候，把链表转化为红黑树的阈值是8,而不是7或者不是20呢？

如果选择6和8（如果链表小于等于6树还原转为链表，大于等于8转为树），中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。

还有一点重要的就是由于treenodes的大小大约是常规节点的两倍，因此我们仅在容器包含足够的节点以保证使用时才使用它们，当它们变得太小（由于移除或调整大小）时，它们会被转换回普通的node节点，容器中节点分布在hash桶中的频率遵循泊松分布，桶的长度超过8的概率非常非常小。所以作者应该是根据概率统计而选择了8作为阀值
## 二）哈希表如何解决Hash冲突？


## 三）为什么HashMap具备下述特点：键-值（key-value）都允许为空、线程不安全、不保证有序、存储位置随时间变化



## 四）为什么 HashMap 中 String、Integer 这样的包装类适合作为 key 键


## 五）HashMap 中的 key若 Object类型， 则需实现哪些方法?


原文链接：[https://blog.csdn.net/qq_36520235/article/details/82417949](https://blog.csdn.net/qq_36520235/article/details/82417949)

# 十三.使用接口的核心原因: 
1. 为了能够向上转型为多个基类型(以及也由此而来的灵活性)
2. 第二个原因与使用抽象基类相同:防止客户端程序员创建该类的对象,并确保这仅仅是建立一个接口.

#### 使用接口还是抽象类?
1. 如果要创建不带任何方法定义和成员变量的基类,那么就应该选择接口而不是抽象类
2. 如果知道某事物应该成为一个基类,那么第一选择应该是使它成为一个接口.
    
# 十四.内部类和嵌套类的区别
1. 普通内部类对象隐式的保存了一个引用,只想创建他的外围类对象;
2. 嵌套类声明为static时:1).要创建嵌套类对象,并不需要外围类的对象;
2).不能从嵌套类的对象访问非静态的外围类对象.
3. 普通内部类的字段和方法,只能放在类的外部层次上,所以普通的内部类不能有static数据和static字段,也不能包含嵌套类,但是嵌套类可以包含所有这些东西.

# 十五.RTTI和反射的区别
1. 对RTTI来说,编译器在编译时打开和检查.class文件.
2. 对反射机制来说,.class文件在编译时是不可获取的,所以是在运行时打开和检查.class文件.

# 十六. wait()和sleep()的区别
sleep来自Thread类，而wait来自Object类
调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁
sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU
sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒
这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。 sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。
锁: 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。　　 　　
 sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。
一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待其他线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。
sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。 Thread.sleep(0)的作用是“触发操作系统立刻重新进行一次CPU竞争”。
使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。
# 十七.什么是线程池，线程池的作用是什么
线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。就好比原来去食堂打饭是每个人看谁抢的赢，谁先抢到谁先吃，有了线程吃之后，就是排好队形，今天我跟你关系好，你先来吃饭。比如：一个应用要和网络打交道，有很多步骤需要访问网络，为了不阻塞主线程，每个步骤都创建个线程，在线程中和网络交互，用线程池就变的简单，线程池是对线程的一种封装，让线程用起来更加简便，只需要创一个线程池，把这些步骤像任务一样放进线程池，在程序销毁时只要调用线程池的销毁函数即可。
单个线程的弊端：a. 每次new Thread新建对象性能差b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或者OOM,c. 缺乏更多功能，如定时执行、定期执行、线程中断。
java提供的四种线程池的好处在于：a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。c. 提供定时执行、定期执行、单线程、并发数控制等功能。
# 十八.Java 线程池
Java通过Executors提供四种线程池，分别为：
newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
(1). newCachedThreadPool
创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。
(2). newFixedThreadPool
创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
(3) newScheduledThreadPool
创建一个定长线程池，支持定时及周期性任务执行。ScheduledExecutorService比Timer更安全，功能更强大
(4)、newSingleThreadExecutor
创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行著作权归作者所有。
# 十九. 静态属性和静态方法是否可以被继承？是否可以被重写？原因
可以被继承，但不能被重写而是隐藏。
原因：静态方法是类在加载时就被加载到内存中的方法，在整个运行过程中保持不变，因而不能重写。但非静态方法是在对象实例化时才单独申请内存空间，为每一个实例分配独立的运行内存，因而可以重写。
1). 静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成对，不需要继承机制及可以调用。如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为"隐藏"。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成，至于是否继承一说，子类是有继承静态方法和属性，但是跟实例方法和属性不太一样，存在"隐藏"的这种情况。
2). 多态之所以能够实现依赖于继承、接口和重写、重载（继承和重写最为关键）。有了继承和重写就可以实现父类的引用指向不同子类的对象。重写的功能是："重写"后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。
3). 静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象。非静态方法可以被继承和重写，因此可以实现多态。
# 二十：为什么匿名内部类引用方法体中的局部变量要使用final标记？匿名内部类和静态内部类的区别，内部类的优点，两者的性能差距
内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用.
内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。
在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类改变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。
简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。
故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。
# 二十一.JAVA 垃圾回收与内存分配策略
21.1 垃圾回收是什么？
就是释放那些不再持有引用的对象的内存
21.2 怎么判断一个对象是否需要收集？
引用计数（最简单古老的方法）：指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程
对象引用遍历（现在大多数 jvm 使用的方法）：对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集.垃圾回收是在虚拟机空闲的时候或者内存紧张的时候执行的，什么时候回收并不是由程序员控制的，可达与不可达的概念：分配对象使用new关键字，释放对象时，只需将对象的引用赋值为null，让程序不能够在访问到这个对象，则称该对象不可达。
引用计数缺陷：引用计数无法解决循环引用问题：假设对象A，B都已经被实例化，让A=B,B=A,除此之外这两个对象再无任何引用，此时计数器的值就永远不可能为0，但是引用计数器无法通知gc回收他们
在以下情况中垃圾回收机制会被触发：
（1）所有实例都没有活动线程访问 ；
（2）没有其他任何实例访问的循环引用实例；
（3）Java中有不同的引用类型。判断实例是否符合垃圾收集的条件都依赖于它的引用类型
21.3 Java的四种引用的区别
什么是StorgReference、WeakReference、SoftWeakReference？有什么区别?
四种引用，强弱软虚，用到的场景
强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM 也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象
软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。
弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象
虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。
21.4 介绍垃圾回收机制
标记回收法：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片
标记-压缩回收法：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率
复制回收法：把现有内存空间分成两部分，gc运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。
分代回收发：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法
21.5 JAVA 中堆和栈的区别
基本数据类型比变量和对象的引用都是在栈分配的
堆内存用来存放由new创建的对象和数组
类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中
实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的"物理位置”,实例变量的生命周期--当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存
局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放;
21.6 JAVA中什么样的对象才能作为gc root, gc roots 有哪些?
GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。
GC Root
常说的GC(Garbage Collector) roots，特指的是垃圾收集器（Garbage Collector）的对象，GC会收集那些不是GC roots且没有被GC roots引用的对象。
一个对象可以属于多个root，GC root有几下种：
Class - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots。
Thread - 活着的线程
Stack Local - Java方法的local变量或参数
JNI Local - JNI方法的local变量或参数
JNI Global - 全局JNI引用
Monitor Used - 用于同步的监控对象
Held by JVM - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。然而，JVM并没有为这些对象提供其它的信息，因此需要去确定哪些是属于"JVM持有"的了。
在Java语言里，可作为GC Roots对象的包括如下几种： 
a.虚拟机栈(栈桢中的本地变量表)中的引用的对象 
b.方法区中的类静态属性引用的对象 
c.方法区中的常量引用的对象 
d.本地方法栈中JNI的引用的对象

# 二十二. Override和Overload的含义去区别
Overload顾名思义是重新加载，它可以表现类的多态性，可以是函数里面可以有相同的函数名但是参数名、返回值、类型不能相同；或者说可以改变参数、类型、返回值但是函数名字依然不变。 Override顾名思义就是ride(重写)的意思，在子类继承父类的时候子类中可以定义某方法与其父类有相同的名称和参数，当子类在调用这一函数时自动调用子类的方法，而父类相当于被覆盖（重写）了。
# 二十三. Object有哪些公用方法？
clone() 创建并返回此对象的一个副本。
equals(Object obj) 指示其他某个对象是否与此对象“相等”。
finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
getClass() 返回此 Object 的运行时类Class类。
hashCode() 返回该对象的哈希码值。
notify() 唤醒在此对象监视器上等待的单个线程。
notifyAll() 唤醒在此对象监视器上等待的所有线程。
toString() 返回该对象的字符串表示。
wait() 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。
wait(long timeout) 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。
wait(long timeout, int nanos) 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。
# 二十四. lock和synchorinzed的区别
synchronized是托管给JVM执行的，而lock是java写的控制锁的代码
synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。
而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。
# 二十五.关于Java反射的性能问题及其常见的处理方法
* 

原因
纠其原因，性能的开销主要在两方面：

1.产生了Dynamic Resolve
无论是通过字符串获取Class、Method还是Field，都需要JVM的动态链接机制动态的进行解析和匹配，势必造成性能开销。
2.安全性验证
每一次的反射调用都会造成Java安全机制进行额外的安全性验证，造成性能开销。
3.影响运行时优化
反射代码使得许多JVM的运行时优化无法进行。

处理方法
针对此，常见的处理方法主要有以下几种：
1.使用Cache
针对上述原因1: 对通过反射调用获得的Class、Method、Field实例进行缓存，避免多次Dynamic Resolve。
2.使用MethodHandle类
针对上述原因2：Java 7开始提供了java.lang.invoke.MethodHandle类，MethodHandle类的安全性验证在获取实例时进行而不是每次调用时都要进行验证，减小开销。
3.使用Runtime创建的类
该方法最为强大，可以针对上述原因1、2、3进行全面优化。具体做法为：
    * 在编译时设计好一个接口，由该接口封装所有的反射调用。
    * 在运行时动态生成一个类实现该接口，该动态生成的类一旦完成define就和普通类没有区别，不需要后续的Dynamic Resolve，没有额外的安全性验证，也不会影响JVM的运行时优化。
该方法不能覆盖反射API的所有Use case，例如某个反射调用需要修改某实例的private字段，是无法动态生成一个合法的类这样去做的。
关于具体如何动态生成符合条件的类可以参考Javassit，本质上还是用到了Classloader截获技术，这种技术是有限制的，例如在安全性级别较高的Applet运行环境中就有很多使用限制。
# 二十六.什么是线程安全？保障线程安全有哪些手段？
线程安全就是当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。保证线程安全可从多线程三特性出发：
    1. 原子性（Atomicity）：单个或多个操作是要么全部执行，要么都不执行
        * Lock：保证同时只有一个线程能拿到锁，并执行申请锁和释放锁的代码
        * synchronized：对线程加独占锁，被它修饰的类/方法/变量只允许一个线程访问
    2. 可见性（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改
        * volatile：保证新值能立即同步到主内存，且每次使用前立即从主内存刷新；
        * synchronized：在释放锁之前会将工作内存新值更新到主存中
    3. 有序性（Ordering）：程序代码按照指令顺序执行
        * volatile： 本身就包含了禁止指令重排序的语义
        * synchronized：保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入